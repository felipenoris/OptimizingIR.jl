<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · OptimizingIR.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">OptimizingIR.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Case-Study-1"><span>Case Study</span></a></li><li><a class="tocitem" href="#Julia&#39;s-compilation-steps-1"><span>Julia&#39;s compilation steps</span></a></li><li><a class="tocitem" href="#Using-OptimizingIR-1"><span>Using OptimizingIR</span></a></li></ul></li><li><a class="tocitem" href="api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/felipenoris/OptimizingIR.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="OptimizingIR.jl-1"><a class="docs-heading-anchor" href="#OptimizingIR.jl-1">OptimizingIR.jl</a><a class="docs-heading-anchor-permalink" href="#OptimizingIR.jl-1" title="Permalink"></a></h1><p>&lt;blockquote&gt;&lt;i&gt; &quot;Compilers&lt;br&gt; Keep on compilin&#39;&lt;br&gt; Cause it won&#39;t be too long&quot;&lt;br&gt;&lt;/i&gt; Wonder, S. &lt;/blockquote&gt;</p><p>This package provides an <a href="https://en.wikipedia.org/wiki/Intermediate_representation">Intermediate Representation (IR)</a> that you can use to build Julia functions at runtime.</p><p>In this IR you can define operations with optimization annotations, so that the IR can run optimization passes in order to generate efficient code.</p><p>The IR can be either interpreted or compiled to machine code. Each approach has a trade-off:</p><ul><li><p>interpreting the IR has no compilation step, but results in a slower execution time when running the function;</p></li><li><p>compiling the IR to machine code builds a Julia expression for the function body and</p></li></ul><p>goes through the Julia&#39;s JIT overhead, but the execution time is faster.</p><p>Also, interpreting the IR lets the user inspect each step in the calculation. This is useful for implementing auto-generation of documentation on the calculation performed by the function.</p><p>This package is not very useful if you can write your function by hand. It should be useful for you if you ever find yourself programmatically building functions out of <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/#Expressions-and-evaluation-1">Julia Expressions</a> when translating from other high-level languages.</p><h1 id="Case-Study-1"><a class="docs-heading-anchor" href="#Case-Study-1">Case Study</a><a class="docs-heading-anchor-permalink" href="#Case-Study-1" title="Permalink"></a></h1><h2 id="Julia&#39;s-compilation-steps-1"><a class="docs-heading-anchor" href="#Julia&#39;s-compilation-steps-1">Julia&#39;s compilation steps</a><a class="docs-heading-anchor-permalink" href="#Julia&#39;s-compilation-steps-1" title="Permalink"></a></h2><p>Let&#39;s start with a simple Julia function.</p><pre><code class="language-julia">julia_basic_block_test_function(x::Number) = (((-((10.0 * 2.0 + x) / 1.0) + (x + 10.0 * 2.0) + 1.0) * 1.0 / 2.0) + (0.0 * x) + 1.0) * 1.0
julia_basic_block_test_function(10.0)</code></pre><pre><code class="language-none">1.5</code></pre><p>Inspecting Julia&#39;s lowered IR we can see that <code>%1</code> and <code>%5</code> are the same constants, and are not re-used in later instructions.</p><pre><code class="language-julia">julia&gt; @code_lowered julia_basic_block_test_function(10.0)
CodeInfo(
1 ─ %1  = 10.0 * 2.0
│   %2  = %1 + x
│   %3  = %2 / 1.0
│   %4  = -%3
│   %5  = 10.0 * 2.0
│   %6  = x + %5
│   %7  = %4 + %6 + 1.0
│   %8  = %7 * 1.0
│   %9  = %8 / 2.0
│   %10 = 0.0 * x
│   %11 = %9 + %10 + 1.0
│   %12 = %11 * 1.0
└──       return %12
)</code></pre><p>The typed IR is better at constant propagation, but stil repeats a few operations.</p><pre><code class="language-julia">julia&gt; @code_typed julia_basic_block_test_function(10.0)
CodeInfo(
1 ─ %1  = Base.add_float(20.0, x)::Float64
│   %2  = Base.div_float(%1, 1.0)::Float64
│   %3  = Base.neg_float(%2)::Float64
│   %4  = Base.add_float(x, 20.0)::Float64
│   %5  = Base.add_float(%3, %4)::Float64
│   %6  = Base.add_float(%5, 1.0)::Float64
│   %7  = Base.mul_float(%6, 1.0)::Float64
│   %8  = Base.div_float(%7, 2.0)::Float64
│   %9  = Base.mul_float(0.0, x)::Float64
│   %10 = Base.add_float(%8, %9)::Float64
│   %11 = Base.add_float(%10, 1.0)::Float64
│   %12 = Base.mul_float(%11, 1.0)::Float64
└──       return %12
) =&gt; Float64</code></pre><p>Why is that, given that Julia should generate very efficient code? Well, nothing is wrong really. Julia just doesn&#39;t have enough information to optimize instructions in the early phase of the Julia IR.</p><p>When the Julia compiler reaches the LLVM phase, it generates efficient code.</p><pre><code class="language-julia">julia&gt; @code_llvm julia_basic_block_test_function(10.0)

;  @ REPL[1]:1 within `julia_basic_block_test_function&#39;
define double @julia_julia_basic_block_test_function_16035(double) {
top:
; ┌ @ float.jl:395 within `+&#39;
   %1 = fadd double %0, 2.000000e+01
; └
; ┌ @ operators.jl:529 within `+&#39; @ float.jl:395
   %2 = fsub double %1, %1
   %3 = fadd double %2, 1.000000e+00
; └
; ┌ @ float.jl:401 within `/&#39;
   %4 = fmul double %3, 5.000000e-01
; └
; ┌ @ float.jl:399 within `*&#39;
   %5 = fmul double %0, 0.000000e+00
; └
; ┌ @ operators.jl:529 within `+&#39; @ float.jl:395
   %6 = fadd double %5, %4
   %7 = fadd double %6, 1.000000e+00
; └
  ret double %7
}</code></pre><p><em>So, why bother using another IR?</em></p><p>Well, if you&#39;re programmatically building functions out of Julia Expressions, you may reach a billion nodes on a single Julia Expression instead of a few thousand nodes that should be sufficient if you had optimizations enabled.</p><h2 id="Using-OptimizingIR-1"><a class="docs-heading-anchor" href="#Using-OptimizingIR-1">Using OptimizingIR</a><a class="docs-heading-anchor-permalink" href="#Using-OptimizingIR-1" title="Permalink"></a></h2><p>By using OptimizingIR you give the compiler sufficient information to perform early optimization passes as you build the IR.</p><pre><code class="language-julia">import OptimizingIR
const OIR = OptimizingIR

# define op-codes with optimization annotations
const op_sum = OIR.Op(+, pure=true, commutative=true, hasleftidentity=true, hasrightidentity=true, identity_element=0)
const op_sub = OIR.Op(-, pure=true, hasrightidentity=true, identity_element=0)
const op_mul = OIR.Op(*, pure=true, commutative=true, hasleftidentity=true, hasrightidentity=true, identity_element=1)
const op_div = OIR.Op(/, pure=true, hasrightidentity=true, identity_element=1)

bb = OIR.BasicBlock()
x = OIR.ImmutableVariable(:x)
OIR.addinput!(bb, x)
arg1 = OIR.constant(10.0)
arg2 = OIR.constant(2.0)
arg3 = OIR.addinstruction!(bb, OIR.call(op_mul, arg1, arg2))
arg4 = OIR.addinstruction!(bb, OIR.call(op_sum, arg3, x))
arg5 = OIR.constant(1.0)
arg6 = OIR.addinstruction!(bb, OIR.call(op_div, arg4, arg5))
arg7 = OIR.addinstruction!(bb, OIR.call(op_sub, arg6))
arg8 = OIR.addinstruction!(bb, OIR.call(op_sum, x, arg3))
arg9 = OIR.addinstruction!(bb, OIR.call(op_sum, arg8, arg7))
arg10 = OIR.addinstruction!(bb, OIR.call(op_sum, arg9, arg5))
arg11 = OIR.addinstruction!(bb, OIR.call(op_mul, arg10, arg5))
arg12 = OIR.addinstruction!(bb, OIR.call(op_div, arg11, arg2))
arg13 = OIR.constant(0.0)
arg14 = OIR.addinstruction!(bb, OIR.call(op_mul, arg13, x))
arg15 = OIR.addinstruction!(bb, OIR.call(op_sum, arg14, arg12))
arg16 = OIR.constant(1.0)
arg17 = OIR.addinstruction!(bb, OIR.call(op_sum, arg16, arg15))
arg18 = OIR.addinstruction!(bb, OIR.call(op_mul, arg16, arg17))
var_output = OIR.MutableVariable(:output)
OIR.addoutput!(bb, var_output)
OIR.assign!(bb, var_output, arg18)

println(bb)</code></pre><pre><code class="language-none">BasicBlock
---------------

Instructions
---------------
1 |  Pure  | call(+, 20.0::Float64, x)
2 |  Pure  | call(-, %1)
3 |  Pure  | call(+, %1, %2)
4 |  Pure  | call(+, %3, 1.0::Float64)
5 |  Pure  | call(/, %4, 2.0::Float64)
6 |  Pure  | call(*, 0.0::Float64, x)
7 |  Pure  | call(+, %6, %5)
8 |  Pure  | call(+, 1.0::Float64, %7)
9 | Impure | output = %8
---------------

Inputs
---------------
1 | x
---------------

Variables - Local Mutables
---------------
output
---------------

Variables - Local Immutables
---------------
---------------

Outputs
---------------
1 | output
---------------</code></pre><p>From an IR, you can compile it to a function.</p><pre><code class="language-julia">finterpreter = OIR.compile(OIR.BasicBlockInterpreter, bb)
println(&quot;finterpreter(10.0) = $( finterpreter(10.0) )&quot;)
fnative = OIR.compile(OIR.Native, bb)
println(&quot;fnative(10.0) = $( fnative(10.0) )&quot;)</code></pre><pre><code class="language-none">finterpreter(10.0) = 1.5
fnative(10.0) = 1.5</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="api/">API Reference »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 25 February 2020 03:48">Tuesday 25 February 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
